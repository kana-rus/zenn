---
title: "合格発表の瞬間に内容をLINEへ送りたかった話"
emoji: "🌟"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go", "Heroku", "GAS", "LINE"]
published: false
---
初投稿です。よろしくお願いします。
# Introduction
大学入試が終わって合格発表を待ってる期間って暇ですよね。僕は暇でした。それで、せっかくなので高校生最後の思い出になるものを作りたいと思って、こんなことを考えました。
### Plan：
1. 合格発表ページをスクレイピングして合格した番号の一覧と自分の合否を調べるコードを書く
2. １のデータを返すAPIを作る
3. 合格発表のタイミング (3/10 12：00) に２のAPIを叩いてデータを取得し、メッセージとしてLINEに送る

データを取得したならそのまま直接MessagingAPIを叩けばいいところですが、「1：**Go**入門としてGoでスクレイピングしてみたい」「2：API作ってみたい」「3：**MessagingAPI**使ってみたい」という動機からこの構成にしました。
対象ページは[京大工学部の合格発表ページ](https://daigakujc.jp/pa.php?u=31&h=24&f=19)です(3/17 17:00まで掲載)。また、今回２では**Heroku**、３では**GAS**を採用しました。
```mermaid
sequenceDiagram
    participant 対象ページ
    participant Go on Heroku
    Go on Heroku->>対象ページ: Scrape
    対象ページ->>Go on Heroku: Data
    GAS->>Go on Heroku: GET
    Go on Heroku->>GAS: Data
    GAS->>LINEアプリ: Message
    Note over GAS,LINEアプリ: by Messaging API
```
GASも初めて触りましたが、これはほぼJSでそこまで困ることなく書けたので、コードを示すに留め、この記事では１のスクレイピングに焦点を当てたいと思います。

```gs:main.gs
let apiURL = PropertiesService.getScriptProperties().getProperty('API_URL')
let userID = PropertiesService.getScriptProperties().getProperty('USER_ID')
let accessToken = PropertiesService.getScriptProperties().getProperty('CHANNEL_ACCESS_TOKEN')

function main() { // 3/10 12:00 実行
  Utilities.sleep(3 * 1000) // スクレイピング完了を待つ (３秒はちょっと長め)
  let jsonData = GetJSONdata(apiURL)

  let idList = jsonData["id_list"]
   // MessagingAPI の文字数制限 (５０００文字) のため２回にわけて送る
  let message1 = idList.slice(0,501).join("\n")
  PushMessage(message1)
  let message2 = idList.slice(501).join("\n")
  PushMessage(message2)

   // 合格or不合格
  let passed = jsonData["passed"]
  let result = ""
  if (passed) {
    result = "合格"
  } else {
    result = "不合格"
  }
  PushMessage(result)
}

function AwakeHeroku(){ // 3/10 11:45 実行
  UrlFetchApp.fetch(apiURL)
}


function GetJSONdata(url){
  let res = UrlFetchApp.fetch(url).getContentText()
  return JSON.parse(res)
}

function PushMessage(messageText){
  let url = 'https://api.line.me/v2/bot/message/push'
  let headers = {
    'Content-Type': 'application/json; charset=UTF-8',
    'Authorization': 'Bearer ' + accessToken,
  }
  let postData = {
    'to': userID,
    'messages': [{
      'type': 'text',
      'text': messageText,
    }]
  }
  let options = {
    'method': 'post',
    'headers': headers,
    'payload': JSON.stringify(postData)
  }
  return UrlFetchApp.fetch(url, options)
}
```
:::message
- GAS は Zenn のシンタックスハイライト未対応
- Property と Trigger は別ファイルで設定済
:::

# Scraping
### 情報収集
では本題に入ります。早速ですが、重大な問題があります。勘のいい方or京大の先輩方は気づいたかもしれませんが、合格発表前はそもそも対象ページがWeb上に存在しません。ページ自体が合格発表のタイミングで公開されるので、事前にURLも分かりませんし、HTMLの構造も当然分かりません。これでは話が進まないので、YouTubeで京大の合格発表ページが写っている動画を探しまくって情報収集しました。その結果分かったことは、
- 発表時刻に、[このページ](https://daigakujc.jp/pal.php?u=31&h=24)に各学科名のリンクが並ぶ：**Aページ**とする
![](https://storage.googleapis.com/zenn-user-upload/c3b857af90a7-20220311.png =450x)
*発表前*
- "工学部"のリンクで飛んだ先が工学部の発表ページ。そのURLは上記ページのURLにクエリパラメータ"f=整数"がくっついた形をしているが、これは毎年同じとは限らないかもしれないとなると、予想がつかない
- 発表ページ自体は、簡単な説明と縦に並んだ番号があるだけ：**Bページ**とする
![](https://storage.googleapis.com/zenn-user-upload/d9ac66054517-20220311.png =450x)
*これは発表後に撮った実際の写真だが、こんな感じのページだということは動画で事前に確認できた* 

くらいです。この条件で、発表の瞬間にBページから
- 合格した番号+アルファベット(画像参照) の一覧
- 自分の合否

を取得するのが目標です。前者ができれば後者は容易なので、前者をなんとかすることを考えることになります。Go の基礎文法をざっと勉強してから、Go でのスクレイピングにはどんな package が使えるか調べてみたところ、**goquery** という package が、GitHub のスター数が十分多く、最終更新が去年の10月で安定してそう、かつネット上の日本語記事数の点では頭一つ抜けているように感じたので、今回はこれを採用することにしました。

### 構想
ということで、goquery に慣れるべくいろいろ書いてみながら、今回の目標を達成するために次のような方針を立てました。

1. Aページをスクレイピングし、「text が"工学部"となっている a タグの href」を取得する。
2. href を"https://..."の形に加工し、そのURLで再度スクレイピングする。これでBページをスクレイピングすることができる。
3. Bページから、合格した「受験番号+アルファベット」(：**ID**とする) のリストを取得する。

ただし、最初に書いたようにBページのHTMLは事前に見られないため、ここは想像に頼るしかないです。当然テストも不可能です。